### 1. MVC和MVVM
1. MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构
  - View 负责页面的显示逻辑
  - Model 负责存储页面的业务数据，以及对相应数据的操作
  - Controller 主要负责用户与应用的响应操作
2. MVVM 分为 Model、View、ViewModel：
  - Model代表数据模型，数据和业务逻辑都在Model层中定义；
  - View代表UI视图，负责数据的展示；
  - ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作

### 2. v-model的原理
作用：在组件上实现双向数据绑定，在代码背后，模版编译器会对v-model做冗长的等价展开
原理：通过Object.defineProperty()实现

### 3. 为什么组件的data必须是一个函数
因为在js中对象是引用类型的数据，多个实例引用同一个对象时，只要有一个实例对这个对象进行了操作，其他实例中的数据也会发生改变<br>
而在 vue 组件中，希望组件之间时互不影响的，所以要写成函数的形式，使每个实例可以维护一份被返回对象的独立的拷贝

### 4. v-if和v-show的区别
v-if：不满足条件时，不渲染dom，更小的初始开销
v-show：通过display属性判断显隐，更小的切换开销

### 5. $nextTick的作用
本质上是vue对js执行原理eventloop的一种应用，作用是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

### 6. v-for和v-if
v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中，因此一般不连用。v-if可以放在外层元素

### 7. watch 和 computed区别
computed：模板中放入太多的逻辑会让模板过重且难以维护，因此引入了computed，计算属性是基于响应式依赖进行缓存的
watch：用来响应数据的变化，当需要在数据变化时执行异步或开销较大的操作时使用

### 8. 组件通信
1. 父组件通过props给子组件传值
2. 通过ref和&refs来实现父子通信，ref定义在子组件上，通过$refs实例访问组件的数据和方法，
4. provide/inject，父组件中通过provide提供变量，子组件通过inject注入组件
3. 子组件通过$emit绑定一个监听事件，当事件被执行时将参数传递给父组件，父组件通过v-on监听并接受参数
4. 兄弟组件通信通过全局事件总线bus，使用 EventBus.$emit() 发送事件，通过EventBus.$on()接收事件，
const EventBus = new Vue();通过 EventBus.$off()移除事件

### 9. 和react的异同
相似之处：
- 都有自己的构建工具
- 都使用 Virtual DOM 保证重绘性能
- 都有 props，允许组件间数据传递
- 都鼓励组件化应用
不同之处
- Vue默认支持数据双向绑定，React提倡单项数据流
- 在渲染中，Vue不会重新渲染整个组件树，而react的状态被修改时，子组件会重新渲染，需要通过PureComponent/shouldComponentUpdate优化
- Vue编写模版的方式接近于HTML，React则通过JSX编写

### 10. keep-alive
<keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们，用于保留组件状态或避免重新渲染。

### 11. mixin
mixins 选项接收一个混入对象的数组，这些混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中，来实现组件复用

### 12. key
作为 Vue 的虚拟 DOM 算法提示，在比较新旧节点列表时用于识别 vnode。<br>
没有key时，Vue尽可能的就地更新/复用同类型元素，如果传了key，根据key的变化排列元素，将始终移除/销毁key已经不存在的元素

### 13. slot原理
<slot>元素是一个插槽出口，编辑了父元素提供的内容将在哪里被渲染
实现原理：当子组件的vm实例化时，获取到父组件传入的slot内容，存放到vm.$slot，当子组件渲染时，遇到slot标签，就是用vm.$slot中的内容进行替换<br>

### 14. ref和reactive的区别
+ 从定义数据角度：
  - ref用来定义基本类型数据
  - reactive用来定义对象类型的数据
  - 备注：ref也能用来定义对象类型数据，内部会自动通过reactive转换为代理对象
+ 从原理角度：
  - ref通过Object.defineProperty()的get和set来实现响应式
  - reactive通过Proxy来实现响应式，并通过Reflect来操作源对象内部的数据
+ 从数据读取角度：
  - ref定义的数据，操作需要.value，读取不需要
  - reactive定义的数据，操作与读取均不需要.value

### 15. 权限管理
1. 权限管理一般分为页面权限和按钮权限
2. 具体实现分前后端两种方案：
  - 前端方案会把所有的路由信息配置在前端，根据用户角色的不同获取不同的数据，对用户权限做对比，取出来之后的值以动态方式添加路由<br>
  - 后端方案是把页面路由都存在服务器中，用户登录时根据角色查询其能访问到的页面的路由返回给前端，前端通过动态路由添加
  - 按钮权限通常是实现一个自定义指令，例如v-permission，将按钮要求角色值传给这个指令，通过mounted中判断用户角色和按钮是否有交集，有就保留

