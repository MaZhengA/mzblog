### 1. 作用域
概念：负责收集并维护由所有声明的变量组成的一系列查询，实施一套严格的规则，来确定当前的代码执行时这些变量的可访问性<br>
作用域有两种工作模型：词法作用域和动态作用域<br>

<h4>词法作用域<h4>
大部分语言编译的第一个工作阶段都叫词法化（词法化的过程会对源代码中的字符进行检查），因此定义在词法阶段的作用域被称为词法作用域。词法作用域意味着作用域是由书写代码时函数声明的位置来决定的

<h4>作用域链<h4>
概念：当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止

### 2. 允许跨域的HTML标签
带有src属性的标签：`<script><img><audio><video><embed><iframe>`

### 3. websocket
见 读书笔记->http.md

### 4. Map
简介：JS的对象本质上是键值对集合，但是传统上只能使用字符串做键，Map提供了“值-值”对应，是一种更完善的Hash结构
特点：Map转为数组结构，可以使用拓展运算符<br>
WeakMap和Map的区别，WeakMap只接受对象作为键名，WeakMap指向的对象，不计入垃圾回收机制，和WeakSet一样，没有遍历操作

### 5. Set
简介：类似与数组，但是生成的成员是唯一的，本身是一个构造函数，用来生成Set数据结构<br>
特点：Set内部判断两个值是否相同，类似于全等运算符，区别在于Set认为NaN等于它自身，两个空对象不相等
使用Array.from可以将Set转换为数组<br>
WeakSet与Set的区别，WeakSet的成员只能是对象，不能遍历，因为成员都是弱对象，随时会消失（被垃圾回收机制回收）

### 6. 深拷贝和浅拷贝
1. 赋值
    - 基本数据类型：赋值，赋值之后两个变量互不影响
    ```js
    let a = "muyiy";
    let b = a;
    console.log(b);
    // muyiy

    a = "change";
    console.log(a);
    // change
    console.log(b);
    // muyiy
    ```
    - 引用数据类型：赋址，两个变量具有相同的引用，指向同一个对象，相互之间有影响
    ```js
    let a = {
        name: "muyiy",
            book: {
                title: "You Don't Know JS",
                price: "45"
            }
        }
    let b = a;
    console.log(b);
    // {
    // 	name: "muyiy",
    // 	book: {title: "You Don't Know JS", price: "45"}
    // } 

    a.name = "change";
    a.book.price = "55";
    console.log(a);
    // {
    // 	name: "change",
    // 	book: {title: "You Don't Know JS", price: "55"}
    // } 

    console.log(b);
    // {
    // 	name: "change",
    // 	book: {title: "You Don't Know JS", price: "55"}
    // } 
    ```
2. 浅拷贝
拷贝第一层的基本类型值，以及第一层的引用类型地址。Object.assign()、拓展运算符、Array.prototype.slice()、
3. 深拷贝
深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存，相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。JSON.parse(JSON.stringify(object))、lodash.cloneDeep() 

### 7. 基本类型和引用类型的区别
1. 基本类型：占用空间小，内存固定，保存在栈(自动分配内存空间，会自动释放)中，保存和复制的是值本身，使用typeof来检测数据类型，值不可变
2. 引用数据类型：地址存在栈中，内容存在堆内存中，占据空间大，占用内存不固定，值可变

### 8. 箭头函数和普通函数的区别
1. 声明方式不同：普通函数用过function关键字生成具名函数和匿名函数，箭头函数通过箭头生成匿名函数
2. this指向不同：普通函数的this指向函数运行时所在的对象，是可变的。箭头函数的this是定义时上层作用域中的this，是固定的
```js
// ES6
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}

// ES5
function foo() {
  var _this = this;

  setTimeout(function () {
    console.log('id:', _this.id);
  }, 100);
}

// 说明箭头函数没有this，引用的是上层作用域中的this
```
3. 箭头函数不能当成一个构造函数（因为没有原型，也没有this）


### 9. HTTP/1.1和HTTP/2.0的区别
1. HTTP/2.0实现了多路复用，HTTP/1.1一个连接上只能发送一个请求
2. HTTP/2.0实现了压缩请求头
3. HTTP/2.0实现了服务端推送
4. 实现了websocket
5. 基于HTTPS加密传输，提高了传输数据的可靠性
6. 赋予请求优先级，主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题

### 10. useCallback和useMemo区别
useCallback把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新，
当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。
```js
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],
);

// useCallback(fn, deps) 相当于 useMemo(() => fn, deps)
```
useMemo把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。
```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```
二者区别在于useMemo会调用fn函数并返回结果，useCallback将返回fn而不调用<br>
React.Memo是一个高阶组件，将组件包装在 React.memo 中调用，相同的 props 会渲染相同的结果，默认只进行浅比较，如果要控制对比过程，通过第二个函数来实现