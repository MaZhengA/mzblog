### 1. 作用域
概念：作用域是一套规则，决定了代码区块中变量和其他资源的可见性<br>
作用域有两种工作模型：词法作用域和动态作用域<br>

<h4>词法作用域<h4>
大部分语言编译的第一个工作阶段都叫词法化（词法化的过程会对源代码中的字符进行检查），因此定义在词法阶段的作用域被称为词法作用域。词法作用域意味着作用域是由书写代码时函数声明的位置来决定的
一般来说分为全局作用域、局部作用域、块作用域

<h4>作用域链<h4>
概念：当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止

### 2. 允许跨域的HTML标签
带有src属性的标签：`<script><img><audio><video><embed><iframe>`

### 3. websocket
见 读书笔记->http.md

### 4. Map
简介：JS的对象本质上是键值对集合，但是传统上只能使用字符串做键，Map提供了“值-值”对应，是一种更完善的Hash结构<br>
特点：Map转为数组结构，可以使用拓展运算符<br>
WeakMap和Map的区别：WeakMap只接受对象作为键名，WeakMap指向的对象，不计入垃圾回收机制，和WeakSet一样，没有遍历操作

### 5. Set
简介：类似与数组，但是生成的成员是唯一的，本身是一个构造函数，用来生成Set数据结构<br>
特点：Set内部判断两个值是否相同，类似于全等运算符，区别在于Set认为NaN等于它自身，两个空对象不相等
使用Array.from可以将Set转换为数组<br>
WeakSet与Set的区别：WeakSet的成员只能是对象，不能遍历，因为成员都是弱对象，随时会消失（被垃圾回收机制回收）

### 6. 深拷贝和浅拷贝
1. 赋值
    - 基本数据类型：赋值，赋值之后两个变量互不影响
    ```js
    let a = "muyiy";
    let b = a;
    console.log(b);
    // muyiy

    a = "change";
    console.log(a);
    // change
    console.log(b);
    // muyiy
    ```
    - 引用数据类型：赋值，两个变量具有相同的引用，指向同一个对象，相互之间有影响
    ```js
    let a = {
        name: "muyiy",
            book: {
                title: "You Don't Know JS",
                price: "45"
            }
        }
    let b = a;
    console.log(b);
    // {
    // 	name: "muyiy",
    // 	book: {title: "You Don't Know JS", price: "45"}
    // } 

    a.name = "change";
    a.book.price = "55";
    console.log(a);
    // {
    // 	name: "change",
    // 	book: {title: "You Don't Know JS", price: "55"}
    // } 

    console.log(b);
    // {
    // 	name: "change",
    // 	book: {title: "You Don't Know JS", price: "55"}
    // } 
    ```
2. 浅拷贝
拷贝第一层的基本类型值，以及第一层的引用类型地址。Object.assign()、拓展运算符、Array.prototype.slice()、
3. 深拷贝
深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存，相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。JSON.parse(JSON.stringify(object))、lodash.cloneDeep() 
如果对象的属性是简单类型，使用Object.assign()可以实现深拷贝

### 7. 基本类型和引用类型的区别
1. 基本类型：占用空间小，内存固定，保存在栈(自动分配内存空间，会自动释放)中，保存和复制的是值本身，使用typeof来检测数据类型，值不可变
2. 引用数据类型：地址存在栈中，内容存在堆内存中，占据空间大，占用内存不固定，值可变

### 8. 箭头函数和普通函数的区别
1. 声明方式不同：普通函数用过function关键字生成具名函数和匿名函数，箭头函数通过箭头生成匿名函数
2. this指向不同：普通函数的this指向函数运行时所在的对象，是可变的。箭头函数的this是定义时上层作用域中的this，是固定的
```js
// ES6
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}

// ES5
function foo() {
  var _this = this;

  setTimeout(function () {
    console.log('id:', _this.id);
  }, 100);
}

// 说明箭头函数没有this，引用的是上层作用域中的this
```
3. 箭头函数不能当成一个构造函数（因为没有原型，也没有this）

### 9. HTTP/1.1和HTTP/2.0的区别
1. HTTP/2.0实现了多路复用，HTTP/1.1一个连接上只能发送一个请求
2. HTTP/2.0实现了压缩请求头
3. HTTP/2.0实现了服务端推送
4. 基于HTTPS加密传输，提高了传输数据的可靠性
5. 赋予请求优先级，主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题

### 10. useCallback和useMemo区别
useCallback把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新，
当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。
```js
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],
);

// useCallback(fn, deps) 相当于 useMemo(() => fn, deps)
```
useMemo把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。
```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```
二者区别在于useMemo会调用fn函数并返回结果，useCallback将返回fn而不调用<br>
React.Memo是一个高阶组件，将组件包装在 React.memo 中调用，相同的 props 会渲染相同的结果，默认只进行浅比较，如果要控制对比过程，通过第二个函数来实现

### 11. React16架构
相较于15，增加了调度器Scheduler，在15之前，react的Reconciler采用递归的方式创建虚拟DOM，递归的过程是不能中断的。如果组件数的层级很深，递归会占用线程很多时间，造成卡顿，为了解决这个问题，16将递归中无法中断的更新重构为异步的可中断的更新，以前的用于递归的虚拟DOM结构无法满足需要了，因此Fiber应运而生。

1. React16的架构分为三层：
- Scheduler（调度器）- 调度任务的优先级，高优任务优先进入Reconciler
- Reconciler（协调器）- 负责找出变化的组件
- Renderer（渲染器）- 负责将变化的组件渲染到页面上

2. Fiber的含义
- 作为架构来说，15的数据保存在调用栈中，被称为stack Reconciler，16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler
```js
// 指向父级Fiber节点
this.return = null;
// 指向子Fiber节点
this.child = null;
// 指向右边第一个兄弟Fiber节点
this.sibling = null;
```
- 作为静态数据来说，每个Fiber节点对应一个React element，保存了该组件的类型、对应的DOM节点信息
```js
// Fiber对应组件的类型 Function/Class/Host...
this.tag = tag;
// key属性
this.key = key;
// 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹
this.elementType = null;
// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName
this.type = null;
// Fiber对应的真实DOM节点
this.stateNode = null;
```
- 作为动态的工作单元来说，每个Fiber节点保存了本次更新中组件改变的状态、要执行的工作（增、删、改）

3. Scheduler的原理与实现
包含两个功能：
- 时间切片
本质是模拟实现requestIdleCallback(该函数在浏览器空闲时被调用)
- 优先级调度

### 12. HTTP强缓存弱缓存
1. 强缓存
- HTTP/1.1通过 Caceh-Control 操作缓存，当指定了max-age（单位是秒）时，优先级高于expires
- HTTP/1.0通过首部字段 Expires 操作缓存，会将资源失效的日期告知客户端
2. 协商缓存
强缓存由浏览器确认是否使用缓存，当浏览器没有命中强缓存时就会向服务器发送请求，验证是否命中协商缓存，如果命中了，就返回304状态码，否则返回新的资源数据。<br>

使用If-Modified-Since比较资源更新时间，在 If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器会接受请求，
如果没有更新过资源，则返回304，用于确认代理或客户端拥有的本地资源的有效性，获取资源更新的时间，通过返回字段Last-Modified来确认<br>

有时用时间比较过期资源并不准确，引入可以使用If-None-Match字段，当 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求

### 13. object.assign 拓展运算符可以实现深拷贝
如果所解构的对象是一维数组或对象，那他就是对基本类型进行等号赋值，就属于是深拷贝，如果是多维数组或对象，其本质就是对引用类型数据进行等号赋值，那它们就是浅拷贝

### 14. useCallback 和 useMemo原理
使用两种方式实现优化效果
  - 减少在一次渲染中需要完成的工作量<br>
  useMemo接受两个参数，把“创建”函数和依赖项数组作为参数传入, 当组件因为其他情况重新渲染，useMemo 就会忽略这个“创建”函数，直接返回之前缓存的值。这个过程叫做memoization
  - 减少一个组件需要重新渲染的次数

### 15. 前端性能优化方式
1. 引入第三方库时，注意导入方式，只导入需要的方法，在构建时就能把该方法抽离出来到处bundle包中
2. webpack的分包、拆包
3. 图片压缩、使用图床工具
4. 静态资源如：静态文件、音频、视频、js资源、图片等放在CDN上边
5. JS资源放在底部执行

### 16. 原型链最多能向上查几层
以__prpto__为节点连起来的链条就叫原型链
```js
// 最多有三层
function Test() {
  this.a = 1;
};

Test.prototype.b = 2;
console.log(Test.prototype); // 函数的prototype

const test = new Test(); // 创建对象
console.log(test.__proto__); // 实例的隐式原型

console.log(test.__proto__ === Test.prototype); // true 对象的__proto保存的是该对象的构造函数的prototype

console.log(Test.prototype.__proto__ === Object.prototype); // true 函数的原型等于Object.prototype

Object.prototype.c = 3;
console.log(Object.prototype.__proto__); // null 顶层对象没有__proto__属性
console.log(Function.__proto__ === Function.prototype); // true 底层规定的
```
### 17. 闭包的适用场景
1. 模拟块级作用域
2. 函数柯里化
```js
// 把一个接受多个参数的函数，转换成接受一个参数，并且返回一个接受余下参数的新函数的技术
// 常见面试题 add(1)(2)(3) = 6;
// arguments 对象是一个类数组对象，包含调用函数时传入的所有参数
function add() {
  // 第一次执行时，定义一个数组专门用来存储所有的参数
  let arg = Array.prototype.slice.call(arguments);
  // 在内部声明一个函数，利用闭包的特性保存arg并收集所有的参数值
  let inner = function() {
    arg.push(...arguments);
    // 内部函数返回内部函数，实现递归
    return inner;
  }
  // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
  inner.toString = function() {
    return arg.reduce((prev, cur) => {
      return prev + cur
    })
  }
  return inner;
}
   
console.log(add(1)(2)(3)(4))

// 简易版
const sum = x => {
  return function(y) {
    return function(z) {
      return x + y + z
    }
  }
}
```
3. 计数器、延迟调用等
4. 参数复用
```js
function curryingCheck(reg) {
  return function(txt) {
  	return reg.test(txt)
  }
}

var hasDigit = curryingCheck(/\d+/g)
var hasLetter = curryingCheck(/[a-z]+/g)

hasDigit('test1')     // true
hasDigit('test')   		// false
hasLetter('123')      // false
```

### 18. 微前端的特性
1. 基于single-spa封装，提供了更开箱即用的API
2. 技术栈无关，任意技术栈均可介入
3. HTML Entry接入方式，接入微应用像iframe一样简单
4. 样式隔离
5. JS沙箱，使微应用之间的全局变量/事件不冲突
6. 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度

### 19. qiankun怎么做隔离的
> shadow dom可以将一个隐藏的、独立的 DOM 附加到一个元素上
#### CSS隔离
解决思路：只需要在应用切除/卸载后，同时卸载掉样式表即可，原理是浏览器会对整个样式表的插入、移除做CSSOM的重构，从而达到修改样式的目的，这样就能保证在一个时间里，只有一个样式表生效。<br>
方案：使用HTML Entry接入方式，直接将子应用打出来的HTML作为入口，卸载时就直接移除HTML结构，可以天然的解决子应用之间样式隔离的问题，极大的减少主应用的接入成本，子应用的开发方式及打包方式基本上也不需要调整
#### JS隔离
方法：使用JS沙箱，确保微应用之间全局变量/事件不冲突<br>
具体实现：在应用的bootstrap和mount两个生命周期开始之前分别给全局状态打下快照，然后当应用切除/卸载时，将状态回滚至bootstrap开始之前的阶段，确保对全局状态的污染全部清空，第二次进入应用的时候，恢复至mount之前的状态，从而确保应用在remount是拥有和第一次mount一致的上下文

### 20. ES6模块与CommonJS模块有什么异同
1. ES6 Module是编译时加载，输出的是接口，CommonJS是运行时加载，加载的是一个对象
2. ES6模块输出的是值的引用，是只读的，不能修改其变量值（指针指向不能变），类似于const。CommonJS输出的是值的拷贝，是一层浅拷贝，可以重新赋值
3. 相同点：都可以修改对象内部属性的值

### 21. this
> 定义：this是执行上下文的一个属性，在非严格模式下，指向最后一次调用他的对象
* this指向
1. 在全局执行环境中，指向全局对象
2. 当函数作为对象方法调用时，this指向这个对象
3. 在构造函数中，this指向新创建的对象
4. 在箭头函数中，继承上级作用域的this

### 22. 执行上下文
变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为，按类型可分为全局上下文和函数上下文
1. 全局上下文就是window 对象，所有通过var 定义的全局变量和函数都会成为window 对象的属性和方法，在应用程序退出前会被销毁
2. 每个函数被调用时，会创建函数上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。
在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript
程序的执行流就是通过这个上下文栈进行控制的